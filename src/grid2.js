// Generated by CoffeeScript 1.3.3
(function() {
  var __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  SNAKE.Grid2 = (function(_super) {

    __extends(Grid2, _super);

    function Grid2(game, snake) {
      this.game = game;
      this.snake = snake;
      Grid2.__super__.constructor.call(this, this.game, this.snake);
      this.squareWidth = 15;
      this.squareHeight = 15;
      this.maxFood = 4;
    }

    Grid2.prototype.moduloBoundaries = function(pair) {
      pair.x %= this.squaresX;
      pair.y %= this.squaresY;
      if (pair.x < 0) {
        pair.x = this.squaresX - 1;
      }
      if (pair.y < 0) {
        pair.y = this.squaresY - 1;
      }
      return pair;
    };

    Grid2.prototype.eachSquare = function(callback) {
      var column, pos, square, x, y, _i, _len, _ref, _results;
      if (!this.world) {
        return;
      }
      _ref = this.world;
      _results = [];
      for (x = _i = 0, _len = _ref.length; _i < _len; x = ++_i) {
        column = _ref[x];
        _results.push((function() {
          var _j, _len1, _results1;
          _results1 = [];
          for (y = _j = 0, _len1 = column.length; _j < _len1; y = ++_j) {
            square = column[y];
            pos = new SNAKE.Pair(x, y);
            _results1.push(callback(pos, square));
          }
          return _results1;
        })());
      }
      return _results;
    };

    Grid2.prototype.eachAdjacentPosition = function(pos, callback) {
      var adjacentPos, direction, normalizedPos, positions;
      positions = {
        down: new SNAKE.Pair(pos.x, pos.y + 1),
        right: new SNAKE.Pair(pos.x + 1, pos.y),
        up: new SNAKE.Pair(pos.x, pos.y - 1),
        left: new SNAKE.Pair(pos.x - 1, pos.y)
      };
      for (direction in positions) {
        adjacentPos = positions[direction];
        normalizedPos = this.moduloBoundaries(adjacentPos);
        if (false === callback(normalizedPos, direction)) {
          return;
        }
      }
    };

    Grid2.prototype.makeWorld = function() {
      Grid2.__super__.makeWorld.call(this);
      return this.world = (function() {
        var _i, _ref, _results;
        _results = [];
        for (_i = 0, _ref = this.squaresX; 0 <= _ref ? _i < _ref : _i > _ref; 0 <= _ref ? _i++ : _i--) {
          _results.push((function() {
            var _j, _ref1, _results1;
            _results1 = [];
            for (_j = 0, _ref1 = this.squaresY; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; 0 <= _ref1 ? _j++ : _j--) {
              _results1.push({});
            }
            return _results1;
          }).call(this));
        }
        return _results;
      }).call(this);
    };

    Grid2.prototype.moveSquare = function(start, end, type) {
      this.world[end.x][end.y][type] = this.world[start.x][start.y][type];
      return this.world[start.x][start.y][type] = null;
    };

    Grid2.prototype.registerSquareAt = function(pos, type) {
      if (this.world[pos.x][pos.y][type]) {
        return false;
      }
      this.world[pos.x][pos.y][type] = true;
      return true;
    };

    Grid2.prototype.unregisterSquareAt = function(pos, type) {
      if (!this.squareHasType(type, pos)) {
        return false;
      }
      this.graphics.hideEntity(this.world[pos.x][pos.y][type]);
      this.world[pos.x][pos.y][type] = null;
      return true;
    };

    Grid2.prototype.squareHasType = function(type, pos) {
      return this.world[pos.x][pos.y][type] != null;
    };

    Grid2.prototype.visibleFood = function() {
      var foodPos, foodPositions, _i, _len, _ref;
      foodPositions = [];
      _ref = this.foodItems._queue;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        foodPos = _ref[_i];
        if (this.graphics.entityIsVisible(this.world[foodPos.x][foodPos.y].food)) {
          foodPositions.push(foodPos);
        }
      }
      return foodPositions;
    };

    return Grid2;

  })(SNAKE.Grid);

}).call(this);
